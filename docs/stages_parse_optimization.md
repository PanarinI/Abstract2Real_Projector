1. Единая функция «запрос + парсинг»
Вместо того чтобы на каждом шаге вручную:

Формировать промпт
Вызывать ask_ai(prompt)
Логировать сырой ответ
Парсить через parse_ai_response
Ловить пустые ответы и т.п.
…можно сделать одну обёртку и вызывать её на каждом шаге. Например:

python
Копировать
Редактировать
def get_parsed_response(prompt: str) -> dict:
    """
    Делает запрос к AI, логирует сырой ответ и результат парсинга,
    возвращает структуру {\"answer\": ..., \"options\": [...]}.
    """
    response = ask_ai(prompt)
    logging.info(f\"Сырой ответ от AI: {response}\")

    parsed = parse_ai_response(response)
    logging.info(f\"Парсированный ответ: {parsed}\")

    return parsed
И в каждом этапе (формат, аудитория, ценность) мы просто пишем:

python
Копировать
Редактировать
parsed_response = get_parsed_response(prompt)
Тем самым мы убираем дублирование кода для логирования и парсинга.

2. Унифицируем промпты
Все три (или больше) шагов хотят одинаковый формат ответа:

text
Копировать
Редактировать
Комментарий: ...
1. [Пиктограмма] [Краткое определение]: ...
2. [Пиктограмма] [Краткое определение]: ...
3. [Пиктограмма] [Краткое определение]: ...
Разница лишь в том, какой контекст мы даём AI (формат, аудитория, ценность). Значит, у каждого шага мы пишем промпт примерно так:

python
Копировать
Редактировать
prompt = f"""
Пользователь выбрал username {username} 
и формат {format_choice} 
и аудиторию {audience_choice}.

Сделай то-то и то-то...

Ответ верни строго по шаблону:

Комментарий: [1-2 предложения]

1. [Пиктограмма] [Краткое определение]: [1-2 предложения]
2. [Пиктограмма] [Краткое определение]: [1-2 предложения]
3. [Пиктограмма] [Краткое определение]: [1-2 предложения]

(не больше 12-15 слов на комментарий и каждый из вариантов)
"""
Важно держать одинаковую структуру для всех этапов.

3. Генерация сообщения и кнопок
Почти во всех шагах однотипно:

Проверяем, что есть варианты (если их нет — ошибка).
Формируем InlineKeyboardMarkup с option["short"].
Отправляем пользователю.
Это тоже можно вынести в одну функцию, если хочется ещё большей чистоты. Например:

python
Копировать
Редактировать
from aiogram.types import InlineKeyboardButton, InlineKeyboardMarkup

def send_parsed_data(message: Message, parsed: dict, callback_prefix: str) -> None:
    # \"parsed\" — это словарь с \"answer\" и \"options\".
    # \"callback_prefix\" — например, \"choose_format\" или \"choose_audience\".

    answer = parsed.get(\"answer\", \"\")
    options = parsed.get(\"options\", [])

    # Формируем текст
    detailed_message = f\"<b>Комментарий:</b>\\n{answer}\\n\\n\"
    detailed_message += \"<b>Варианты:</b>\\n\"
    for opt in options:
        detailed_message += f\"• {opt['full']}\\n\"

    kb = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text=opt['short'], callback_data=f\"{callback_prefix}:{i}\")]
        for i, opt in enumerate(options)
    ])

    # Отправляем ответ
    await message.answer(detailed_message, reply_markup=kb, parse_mode=\"HTML\")
Тогда в самом обработчике:

python
Копировать
Редактировать
parsed_response = get_parsed_response(prompt)

if not parsed_response[\"options\"]:
    await message.answer(\"❌ Ошибка при генерации...\")
    return

await send_parsed_data(query.message, parsed_response, \"choose_format\")
Таким образом, и логика оформления тоже будет единообразной.

4. Следить за единообразием формата
Главное, чтобы промпт на каждом шаге:

Ясно говорил, что нужно вернуть комментарий и 3 варианта.
Без всяких «Вариант N» или «Варианты 1, 2, 3» — только:
less
Копировать
Редактировать
Комментарий:
1. [Пиктограмма] [Краткое определение]: ...
Ограничение слов мы оставляем как friendly-hint.
Парсер будет везде один, так как структура одна. Если AI сбоит (начинает добавлять «Вариант 1» и т. п.), мы его подчищаем, но в идеале при корректном промпте сбоев не будет.

5. «Матрёшка» в итоге
Шаг 1 (start_format_stage):

Вызываем parsed_response = get_parsed_response(…).
Проверяем ошибки.
Отправляем пользователю список форматов.
Шаг 2 (start_audience_stage):

Получаем format_choice из state.
Формируем новый промпт, но с тем же шаблоном.
Снова parsed_response = get_parsed_response(…).
Отправляем пользователю.
Шаг 3 (start_value_stage):

Аналогично, учитывая уже и audience_choice.
Везде одно и то же:

«комментарий: …»
«1. … 2. … 3. …»
Парсер этот же, вывод тот же.
Коротко об оптимизации
Проверки на answer и options можно унифицировать. Например, внутри get_parsed_response (или отдельной функции) можно падать с ошибкой, если options пустые.
Дублирующийся код генерации InlineKeyboard можно вынести в отдельную функцию, как показал выше.
Одинаковые описания prompt можно вынести в шаблоны (например, Jinja2) — тогда мы просто подставляем переменные {username} и {format_choice}.